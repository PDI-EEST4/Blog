---
title: 3.4 - Rutas y modularizaci칩n
topic: Implementaci칩n
slug: rutas_parametros
visible: true
---

# Parametros de rutas y modularizaci칩n

**쯈u칠 son los par치metros de rutas?**
Son formas de manejar URLs din치micas en una API. Express permite definir rutas que capturen valores directamente desde la URL.

**쯇ara qu칠 sirve?**
Para interactuar con recursos espec칤ficos: por ejemplo, obtener un usuario por ID (`/users/123`) o filtrar productos (`/products?category=ropa`).

## Par치metros de Ruta (:param)

Se usan para capturar valores din치micos desde el path:

```js
app.get('/users/:id', (req, res) => {
  const { id } = req.params;
  res.send(`Usuario con ID: ${id}`);
});
```

游댲 Si vas a /users/42, la respuesta ser치: "Usuario con ID: 42"

## Par치metros de Consulta (Query Params)

Son clave-valor en la URL:

```js
app.get('/search', (req, res) => {
  const { q } = req.query;
  res.send(`Buscando: ${q}`);
});
```

游댲 Si vas a /search?q=perro, devuelve "Buscando: perro"

## Par치metros en POST (Body Params)

Se leen del cuerpo de la petici칩n. Requieren middleware:

```js
app.use(express.json());  // Para que express entienda json

app.post('/users', (req, res) => {
  const { name } = req.body;
  res.send(`Creando usuario: ${name}`);
});
```

<hr />

## Modularizaci칩n de Rutas

La modularizaci칩n es el proceso de dividir el c칩digo en partes reutilizables y mantenibles. En Express, esto se traduce en separar las cosas en archivos distintos para no tener todo en el index.js o app.js.

**쯇ara qu칠 sirve?**
Para que tu app no se convierta en una sopa de c칩digo. Mejora la legibilidad, la escalabilidad y permite el trabajo en equipo.

**쯇or qu칠 conocer esto mejora tus habilidades como desarrollador?**
Porque cuando trabaj치s en proyectos reales, si no separ치s las rutas, vas a terminar llorando frente al index.js de 800 l칤neas. Adem치s, esto demuestra que sab칠s mantener limpio un c칩digo backend.

**Ejemplo/Analog칤a:**
Pens치 en una cocina: no ten칠s todos los ingredientes tirados en el piso. Us치s cajones, estantes, frascos. Lo mismo con tu c칩digo: cada cosa en su lugar.

## Ejemplo en c칩digo.

Supongamos que contamos con un archivo como este:

```js
import express from 'express';

const app = express();

app.get('/productos', function (req, res) {
  res.json({
    message: 'Listado de productos'
  });
})

app.post('/productos', function (req, res) {
  res.json({
    message: 'Producto creado'
  });
})

app.put('/productos/:id', function (req, res) {
  res.json({
    message: 'Producto actualizado'
  });
})

app.delete('/productos/:id', function (req, res) {
  res.json({
    message: 'Producto eliminado'
  });
})

app.listen(3000, function () {
  console.log('Servidor escuchando en el puerto 3000');
});
```

Seguramente m치s adelante vamos a querer agregar muchas m치s rutas, ya sea para usuarios, carritos, etc. En ese caso, la soluci칩n es crear un archivo aparte para las rutas y un archivo aparte para las rutas de usuarios y carritos y asi sucesivamente.

쮺칩mo hacemos eso? Es muy sencillo:

1. Creamos una carpeta llamada `routes` dentro de la carpeta de nuestro proyecto
2. Creamos un archivo llamado `[cualquiercosa].routes.js` dentro de la carpeta `routes` (donde `[cualquiercosa]` es el nombre que quieras darle a tu archivo. Ej: `users.routes.js`)
3. Dentro de ese archivo, importamos `express` y lo usamos para crear un router. Adem치s vamos a pasar las rutas que tengamos creadas a ese router

```js
import express from 'express';

const router = express.Router();

/*
Notese que las rutas cambiaron de `/productos` a `/`
Esto es porque ahora tenemos un archivo aparte para las rutas. El prefijo 'productos' se lo vamos a dar en el siguiente paso
*/

router.get('/', function (req, res) {
  res.json({
    message: 'Listado de productos'
  });
})

router.post('/', function (req, res) {
  res.json({
    message: 'Producto creado'
  });
})

router.put('/:id', function (req, res) {
  res.json({
    message: 'Producto actualizado'
  });
})

router.delete('/:id', function (req, res) {
  res.json({
    message: 'Producto eliminado'
  });
})

export default router;  // Lo vamos a querer exportar para llamarlo en nuestro index.js
```

4. En nuestro archivo `index.js`, importamos el router que acabamos de crear:

```js
import express from 'express';
import productosRoutes from './routes/productos.routes.js'; // Importamos el router

const app = express();

app.use('/productos', productosRoutes)

app.listen(3000, function () {
  console.log('Servidor escuchando en el puerto 3000');
});
```

## Conclusion

Lo que hemos hecho es crear un archivo aparte para las rutas, y lo importamos en el index.js. En el index.js, usamos el router que hemos creado para manejar las rutas.

Cuando dividimos la responsabilidad en diferentes archivos, nos ayuda a mantener el c칩digo limpio y organizado. A esto le llamamos **modularizaci칩n**

A medida que los proyectos crecen, la modularizaci칩n se vuelve muy importante.